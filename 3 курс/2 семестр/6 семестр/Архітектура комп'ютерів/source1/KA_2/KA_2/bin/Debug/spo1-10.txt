СПО (1 семестр). Лабораторная работа №1

Аллокатор памяти общего назначения (часть 1)

Краткая теория

Аллокатор памяти общего назначения должен выполнять, по крайней мере, три задачи: выделение блока памяти заданного размера, освобождение выделенного блока памяти и изменение размера выделенного блока памяти. Эти функции со-ставляют интерфейс аллокатора памяти общего назначения:

•	void *mem_alloc(size_t size);

функция должна выделить блок памяти заданного размера в size байт. Если  блок памяти был выделен успешно, то вернуть адрес начала этого блока, в противном случае вернуть NULL.

•	void *mem_realloc(void *addr, size_t size);

функция должна изменить размер блока памяти с адресом addr до size байт. При этом содержимое (всё или часть) старого блока памяти может быть перенесено в другой блок памяти. Если удалось изменить размер бло-ка памяти, то функция должна вернуть адрес нового блока памяти, иначе вернуть NULL и не разрушить старый блок памяти. Если addr равен NULL, то вызов функции аналогичен вызову mem_alloc(size).

•	void mem_free(void *addr);

функция должна освободить прежде выделенный блок памяти.

Несколько замечаний по семантике использования этих функций.

Функцию mem_realloc() можно использовать как для уменьшения, так и для увели-чения размера блока. Эта функция может выделить новый блок памяти по новому адресу, при этом содержимое старого блока всегда копируется в новый блок (всё в случае увеличения или не изменения размера блока, или часть в случае умень-шения размера). Если новый блок успешно выделен, то блок памяти по старому адресу считается недействительным. Если блок нового размера выделить не уда-лось, то возвращается NULL, при этом старый блок памяти должен быть доступен для использования.

Функция mem_free() освобождает выделенный блок памяти, после вызова этой функции этот блок считается недействительным и не может использоваться при-ложением.

Если память выделена функциями mem_alloc() или mem_realloc(), то её нельзя переносить куда либо до вызова mem_free() или mem_realloc(), если mem_realloc() вернула другой адрес.

Построение эффективного аллокатора общего назначение является не простой задачей. Сложность связана с тем, что не известна последовательность вызова функций выделения, освобождения и изменения размеров блоков памяти. Поэто-му говорить об оптимальном, самом лучшем или идеальном решении нельзя.

Существуют несколько методов построения аллокаторов общего назначения. Все эти методы работают следующим образом. Во время инициализации аллокатора запрашивается некоторая область памяти у ОС. При запросе на выделение блока памяти, в этой области памяти ищется свободный блок памяти нужного размера, помечается как занятый и его адрес возвращается приложению. При запросе на освобождение блока памяти, этот блок помечается как свободный. Аналогично реализуется функция изменения размера блока. Если выделенной области памя-ти недостаточно, то выделяется ещё одна область памяти.

Рассмотрим базовый вариант одного из методов построения аллокатора общего назначения.

Каждый блок памяти состоит из заголовка фиксированного размера и данных. В заголовке указывается размер текущего блока, размер предыдущего блока и при-знак занятости блока. Выбирается область памяти, которая содержит хотя бы один свободный блок. Далее в найденной области памяти сканируются все блоки по порядку, и выбирается первый подходящий свободный блок. Найденный блок разделяется на два, один помечается как свободный, а второй помечается как за-нятый и адрес его данных возвращается приложению. Если в найденной области памяти не удалось найти свободный блок достаточного размера, то производится поиск в другой области памяти. При освобождении блока производится склейка с левым и правым свободными блоками.

Оценим этот алгоритм. Если принять, что все блоки выровнены на границу 4 бай-тов (здесь 1 байт это 1 октет), то размер заголовка на 32 битной системе может быть равен 8 байтам. Один бит заголовка показывается занятость блока, осталь-ные биты показывают размер текущего и следующего блоков в байтах. Для N бло-ков потребуется (N*8) байт дополнительной информации. Также потребуется па-мять для хранения статистики и указателей на области памяти. В худшем случае при поиске свободного блока потребуется проверить N заголовков. Освобождение блока происходит быстро, для этого достаточно проверить заголовки левого и правого соседних блоков. Если выполнить 1000 пар запросов на выделение 10 байт и 20 байт, а затем освободить все блоки по 10 байт, то суммарная свободная память будет иметь размер ?18000 байт, но для выделения нового блока в 20 байт возможно потребуется новая область памяти.

Задание на работу

Разработать аллокатор общего назначения, используя за основу описанный выше базовый вариант алгоритма, принимая во внимания следующие условия:

1.	Области памяти можно выделять любым доступным способом.

2.	Функции mem_alloc(), mem_realloc() и mem_free() должны соответствовать приведенным выше прототипам.

3.	Адреса памяти, возвращаемые функциями mem_alloc() и mem_realloc(), должны быть выровнены на границу в 4 байта.

4.	Попытаться уменьшить время поиска свободного блока памяти и время ос-вобождения занятого блока.

5.	Попытаться уменьшить фрагментацию памяти.

6.	Написать функцию mem_dump(), которая должна выводить на консоль со-стояние областей памяти.

Отчёт

Отчёт должен содержать:

1.	Описание разработанного алгоритма.

2.	Оценку времени поиска свободного блока памяти, оценку времени освобо-ждения занятого блока.

3.	Оценку расхода памяти для хранения служебной информации.

4.	Описание достоинств и недостатков разработанного аллокатора.

5.	Листинг аллокатора памяти общего назначения.

6.	Пример работы аллокатора.

Электронная версия (сеть КПИ)

ftp://vt513.comsys.ntu-kpi.kiev.ua/pub/edu/spo1/lab1-1.doc

Литература

1.	Bill Blunden. Memory Management: Algorithms and Implementation in C/C++.

2.	Роберт Седжвик. Фундаментальные алгоритмы на C.

3.	Томас Кормен. Алгоритмы: построение и анализ.

