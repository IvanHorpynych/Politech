/*********************************************************
*file:MyFunc.c
*synopsis:these file contains the realization of functions,which are declarated in the file "MyFunc.h"
*author: Zaika Kirill KV-31
*written:5.10.2014
*last modified:5.10.2014
*********************************************************/

#include "MyFunc.h"

/*******************************************************
*Название: substr
*Использование: int value = substr(str1,str2)
*Прототип в MyFunc.h
*Возврат:ф-ция возвращает индекс на первое вхождение str2 в строке str1
*******************************************************/
int substr(const char *string1, const char *string2){
	/*указатель на 1вое вхождение*/
	char *istr = strstr(string1, string2);
	return (istr != 0) ? istr - string1 : 0;
}

/******************************************************
*Название: subseq
*Использование : int len = subseq(str1,str2)
*Прототип в MyFunc.h
*Cинопсис: ф-ция ищет наиболее общую длинную подпоследовательность
в строках str2 и str1
*Возврат: возвращает длину самой длинной подпоследовательности
******************************************************/


int subseq(const char *string1, const char *string2){
	int i, j, k, l, tmpCount, count;
	i = tmpCount = count = 0; //инициализация переменны-счетчиков
	//метод прямого перебора
	for (; i < (strlen(string2) - 1); i++){
		for (j = 0; j<strlen(string1) - 1; j++){
			tmpCount = 0;
			k = j;
			l = i;
			//если найдены схожие символы,
			//начинается проверка последующих
			while ((string2[l] == string1[k]) && (string2[l] != '\0')){
				k++;
				l++;
				tmpCount++;
			}
			//если новая последовательность больше
			//запоминаем её
			if (tmpCount>count)
				count = tmpCount;
		}

	}
	return count;
}

/*************************************************************
*Название: ispal
*Использование int flag = ispal(palindrome)
*Прототип в MyFunc.h
*Синопсис:ф-ция проверяет строку string, является ли полиндромом
*Возврат: возвращает 1,если палиндром. Иначе 0.
*************************************************************/
char ispal(const char *string){
	/*переменная-счетчик,длинна строки, булевская переменная*/
	int i, n, flag;
	flag = 1;
	for (i = 0, n = strlen(string); i < (strlen(string)) / 2, n >(strlen(string)) / 2; i++, n--){
		/*в цикле проверяются на равенство символ с начала и конца строки,
		пока не пересекутся в середине*/
		if (string[i] != string[n - 1]){
			/*в случае разности, булевская переменная становиться 0
			и прекращается итерация*/
			flag = 0;
			break;
		}
	}
	return (flag == 1) ? 1 : 0;
}

/*************************************************************
*Название: makepal
*Использование char *ptr = makepal(str)
*Прототип в MyFunc.h
*Синопсис: ф-ция проверяет строку string на палиндром
если нет, то достраивает строку с помощью дин.массива
*Возврат: указатель на палиндром
*************************************************************/
char* makepal(char *string){
	int len, count, i = 0;				/*длинна строки,счётчики*/
	char *p;							/*будущая строка-палиндром*/
	len = strlen(string);
	p = calloc(len, sizeof(char));		/*выделяем начальную память*/
	if (!p){							/*если не удалось выделить,
										то возвращаем начальную строку*/
		return string;
	}
	else {
		/*цикл,пока не конец нач.строки*/
		for (i = 0; i < len; i++){
			/*в строку-палиндром заносим все значения нач.строки*/
			p[i] = string[i];
		}
		p[len] = '\0';
		count = strlen(p) + 1;		/*увеличиваем счётчик для выделения памяти*/
		i = 0;
		/*цикл, пока строка не будет  палиндромом*/
		while (ispal(p) == 0){
			p = (char *)realloc(p, count * sizeof(char));	/*выделяем память*/
			if (p != NULL){
				/*если память выделена*/
				/*в первый раз начальный символ переносим в конец*/
				if (i == 0){
					p[count - 1] = string[i];
					p[count] = '\0';
					i++;
					count++;
				}
				/*в остальные разы сдвигаем конец строки вправо
				и на место ставим следующий элемент*/
				else{
					p[count - 1] = p[count - 2];
					p[count - 2] = string[i];
					p[count] = '\0';
					i++;
					count++;
				}
			}
		}
		return p;
	}
}

/**************************************************************
*Название: txt2double
*Использование double *d = txt2double(str1,&n)
*Прототип в MyFunc.h
*Синопсис: функция считает кол-во цифр в строке string,
конвертирует числа из формата строки в вещественные и
заносит их в массив веществ.чисел
*Возврат: возвращает указатель на массив веществ. чисел
*************************************************************/
double *txt2double(const char *string, int *size){
	int i, j, count;					/*переменные-счётчики*/
	i = j = count = 0;

	int flag = 0;						/*переменная для проверки формата цифр*/
	double *ptr = NULL;					/*массив чисел типа double*/
	char *word;							/*массив для "сборки" слов*/
	word = calloc(1, sizeof(char));		/*выделение начальной памяти*/
	for (; i <= (size); i++){		/*цикл,завершающийся при конце строки*/
		/*если получен символ ;
		то выделяется память для массива чисел и заносится конвертированное число*/
		if ((string[i] == ';') || (string[i] == '\0')) {
			word[j] = '\0';
			count++;
			ptr = (double *)realloc(ptr, count * sizeof(double));
			ptr[count - 1] = atof(word);
			/*в случае неудачного конвертирования передаётся значение 0*/
			if (ptr[count - 1] == 0){
				*size = 0;
				return NULL;
			}
			j = 0;
		}
		/*заносится каждый символ первой строки в массив для "сборки"*/
		else {
			word = (char *)realloc(word, (j + 1)*sizeof(char));
			if (word != NULL){
				word[j] = string[i];
				j++;
			}
			else{
				*size = 0;
				return NULL;
			}
		}
	}

	/*при удачном конвертировании строк возвращ. кол-во цифр в строке*/
	/*size = count;*/

	return ptr;
}