/*********************************************************
*Файл:MyFunc1.c
*Синопсис:файл вмещает в себе реализацию функций 
которые объявленны в файле "MyFunc1.h" 
*Автор:Kyrylo Svintsov KV-31
*Написанно:5.10.2014
*Обновленно:7.10.2014
*********************************************************/


#include "MyFunc1.h"

/*******************************************************
*Название: substr
*Использование: int value = substr(str1,str2)
*Прототип в MyFunc1.h
*Возврат:ф-ция возвращает индекс на первое вхождение строки str2
в строке str1
*******************************************************/
int substr(const char *string1, const char *string2){
	/*указатель на первое вхождение*/
	char *istr = strstr(string1, string2);				
	return (istr != 0) ? istr - string1 : 0;			
}

/******************************************************
*Название: subseq
*Использование : int len = subseq(str1,str2)
*Прототип в MyFunc1.h
*Cинопсис: ф-ция ищет наиболее общую длинную подпоследовательность
в строках str2 и str1
*Возврат: возвращает длину самой длинной подпоследовательности
******************************************************/


int subseq(const char *string1, const char *string2){
	int i, j,k,l, tmpCount, count; 
	i = tmpCount = count = 0; //инициализация переменны-счетчиков
	//метод прямого перебора
	for (; i < (strlen(string2) - 1); i++){
		for (j = 0; j<strlen(string1) - 1; j++){
			tmpCount = 0;
			k = j;
			l = i;
			//если найдены схожие символы,
			//начинается проверка последующих
			while ((string2[l] == string1[k]) && (string2[l] != '\0')){
				k++;
				l++;
				tmpCount++;
			}
			//если новая последовательность больше
			//запоминаем её
			if (tmpCount>count)
				count = tmpCount;
		}
		
	}
	return count;
}

/*************************************************************
*Название: ispal
*Использование int flag = ispal(palindrome)
*Прототип в MyFunc1.h
*Синопсис:ф-ция проверяет строку string, является ли полиндромом
*Возврат: возвращает 1,если палиндром. Иначе 0.
*************************************************************/
char ispal(const char *string){
	/*переменная-счетчик,длинна строки, булевская переменная*/
	int i, n, flag;										
	flag = 1;
	for (i = 0, n = strlen(string); i < (strlen(string)) / 2, n >(strlen(string)) / 2; i++, n--){
		/*в цикле проверяются на равенство символ с начала и конца строки,
		пока не пересекутся в середине*/
		if (string[i] != string[n - 1]){				
			/*в случае разности, булевская переменная становиться 0
			и прекращается итерация*/
			flag = 0;									
			break;
		}
	}
	return (flag == 1) ? 1 : 0;
}

/*************************************************************
*Название: makepal
*Использование char *ptr = makepal(str)
*Прототип в MyFunc1.h
*Синопсис: ф-ция проверяет строку string на палиндром
если нет, то достраивает строку с помощью дин.массива
*Возврат: указатель на палиндром
*************************************************************/
char* makepal(char *string){
	int len, count, i = 0;				/*длинна строки,счётчики*/
	char *p;							/*будущая строка-палиндром*/
	len = strlen(string);
	p = calloc(len, sizeof(char));		/*выделяем начальную память*/
	if (!p){							/*если не удалось выделить,
										то возвращаем начальную строку*/
		return string;
	}
	else {
		/*цикл,пока не конец нач.строки*/
		for (i = 0; i < len; i++){				
			/*в строку-палиндром заносим все значения нач.строки*/
			p[i] = string[i];					
		}
		p[len] = '\0';
		count = strlen(p) + 1;		/*увеличиваем счётчик для выделения памяти*/
		i = 0;
		/*цикл, пока строка не будет  палиндромом*/
		while (ispal(p) == 0){							
			p = (char *)realloc(p, count * sizeof(char));	/*выделяем память*/
			if (p != NULL){								    
				/*если память выделенна*/
				/*в первый раз начальный символ переносим в конец*/
				if (i == 0){							
					p[count - 1] = string[i];
					p[count] = '\0';
					i++;
					count++;
				}
				/*в остальные разы сдвигаем конец строки вправо
				и на место ставим следующий элемент*/
				else{									
					p[count - 1] = p[count - 2];
					p[count - 2] = string[i];
					p[count] = '\0';
					i++;
					count++;
				}
			}
		}
		return p;										
	}
}

/**************************************************************
*Название: txt2double
*Использование double *d = txt2double(str1,&n)
*Прототип в MyFunc1.h
*Синопсис: функция считает кол-во цифр в строке string,
конвертирует числа из формата строки в вещественные и 
заносит их в массив веществ.чисел
*Возврат: возвращает указатель на массив веществ. чисел
*************************************************************/
double *txt2double(const char *string, int *size){
	int i, j, count;					/*переменные-счётчики*/
	i = j = count = 0;

	char flag = 0;						/*переменная для проверки формата цифр*/
	double *ptr = NULL;					/*массив чисел типа double*/
	char *word;							/*массив для "сборки" слов*/
	word = calloc(1, sizeof(char));		/*выделение начальной памяти*/
	for (; string[i] != '\0'; i++){		/*цикл,завершающийся при конце строки*/
		/*если получен символ ; 
		то выделяется память для массива чисел и заносится конвертированное число*/
		if (string[i] == ';') {			
			word[i] = '\0';
			count++;
			ptr = (double *)realloc(ptr, count * sizeof(double));
			ptr[count - 1] = atof(word);
			/*в случае неудачного конвертирования передаётся значение 1*/
			if (ptr[count - 1] == 0)	
				flag = 1;
			memset(word, 0, j);
			j = 0;
		}
		/*заносится каждый символ первой строки в массив для "сборки"*/
		else {
			word = (char *)realloc(word, (j + 1)*sizeof(char));	
			word[j] = string[i];
			j++;
		}
	}

	word[j] = '\0';
	count++;
	ptr = (double *)realloc(ptr, count *sizeof(double));
	ptr[count - 1] = atof(word);
	if (ptr[count - 1] == 0)
		flag = 1;
	/*при удачном конвертировании строк возвращ. кол-во цифр в строке*/
	*size = (flag != 1) ? count : 0;	

	return ptr;
}