unit TEST;

interface

 uses
  GLOBAL,WORKAR,TIMER,crt,dos; 
  
procedure Main_1(var a:arr; var C:vector); {Пакетний вивід середніх значень часу роботи алгоритмів}
procedure Main_2(var a:arr; var C:vector);{Пакетний вивід значень часу роботи алгоритмів}

implementation


var ch:char;

procedure Main_1(var a:arr; var C:vector); {Пакетний вивід середніх значень часу роботи алгоритмів}
const n=14;
var var_sort,var_alg,i:integer;
    Min,Max:longint;
    B:array[1..n]of longint; {Вектор для запам'ятовування часу роботи алгоритмів}
    Sum:real;
    T:longint; {Комірка запам'ятовування часу}
begin
clrscr;
writeln('                    Sort    UnSort   BackSort');

UnSortArray(V); {Заповнює додатковий масив рандомними значеннями}

 var_alg:=1; {Початкові значення вибору алгоритму}
 repeat
  var_sort:=1;{Початкові значення вибору методу заповнення масиву}
  case var_alg of {Вибір алгоритму}
   1: begin
        write('Workaround 1:');
        pr:=WORKAR1711;{Процедурному вказівнику присвоюється адреса алгоритму "вставка – обмін" з використанням додаткового масиву}
      end;
   2: begin
        write('Workaround 2:');
        pr:=WORKAR1712; {Процедурному вказівнику присвоюється адреса алгоритму "вставка – обмін" з використанням елементів "уявного" вектора і переведення у відповідні індекси елементів заданого двовимірного масиву}
      end;

   3: begin
        write('Workaround 3:');
        pr:=WORKAR1713; {Процедурному вказівнику присвоюється адреса алгоритму "вставка – обмін" здійснюючи обхід безпосередньо по елементах заданого двовимірного масиву}
      end;
  end;{case}

  repeat
   case var_sort of{Вибір методу заповнення масиву}
    1:  for i:=1 to n do {Лічильник кількості виконання алгоритму}
         begin
          SortArray(A);{Процедура впорядкованного заповнення масиву}
          B[i]:=Time(pr); {Присвоєння комірці вектора часу роботи алгоритма}
         end;
    2: for i:=1 to n do {Лічильник кількості виконання алгоритму}
         begin
          UnSortCopy(A); {Процедура копіюванння з додаткового рандомного масиву у необхідний}
          B[i]:=Time(pr);{Присвоєння комірці вектора часу роботи алгоритма}
         end;
    3: for i:=1 to n do {Лічильник кількості виконання алгоритму}
         begin
          BackSortArray(A); {Процедура заповнення обернено впорядкованного масиву}
          B[i]:=Time(pr); {Присвоєння комірці вектора часу роботи алгоритма}
         end;
   end;{case}

   Min:=B[3]; 
   Max:=B[3];
   for i:=4 to n do {Пошук мінімального та максимального значення часу роботи}
    begin
     if B[i]>Max then Max:=B[i];
     if B[i]<Min then Min:=B[i];
    end;
   Sum:=0;
   for i:=3 to n do Sum:=Sum+B[i];
   Sum:=(Sum-Min-Max)/10; {Знаходження середнього значення роботи алгоритму}
   if var_sort<>3 then Write(Sum:10:1)
    else Writeln(Sum:10:1);

   inc(var_sort); {Зміна вибору методу заповнення масиву}
  until var_sort>3;
  inc(var_alg); {Зміна вибору алгоритму}
 until var_alg>3;
Writeln('Press Enter for continue');
readln;

vec:=SortVector; {Процедурному вказівнику присвоюється адреса алгоритму "вставка – обмін" сортування вектора}
  SortVect(C);{Процедура впорядкованного заповнення вектора}
  T:=TimeVector(vec); {Комірці запам'ятовування часу присвоюється значення часу роботи алгоритму}
  writeln('Sort Vector:',T*p); {Вивід на екран теоретичного значення роботи алгоритму з вектором}
  UnSortVect(C); {Процедура невпорядкованного заповнення вектора}
  T:=TimeVector(vec); {Комірці запам'ятовування часу присвоюється значення часу роботи алгоритму}
  writeln('UnSort Vector:',T*p); {Вивід на екран теоретичного значення роботи алгоритму з вектором}
  BackSortVect(C); {Процедура заповнення обернено впорядкованного вектора}
  T:=TimeVector(vec); {Комірці запам'ятовування часу присвоюється значення часу роботи алгоритму}
  writeln('BackSort Vector:',T*p); {Вивід на екран теоретичного значення роботи алгоритму з вектором}

  Writeln('Press Enter for continue');
ch:=readkey;
if ch=#32 then exit;{Вихід з роботи процедури} 
end;

procedure Main_2(var a:arr; var C:vector); {Пакетний вивід значень часу роботи алгоритмів}
var var_sort,var_alg,i:integer;
T,B:longint; {Комірки запам'ятовування часу}
begin
clrscr;
writeln('                    Sort    UnSort   BackSort');

UnSortArray(V);{Заповнює додатковий масив рандомними значеннями}

 var_alg:=1; {Початкові значення вибору алгоритму}
 repeat
  var_sort:=1; {Початкові значення вибору методу заповнення масиву}
  case var_alg of {Вибір алгоритму}
   1: begin
        write('Workaround 1:');
        pr:=WORKAR1711; {Процедурному вказівнику присвоюється адреса алгоритму "вставка – обмін" з використанням додаткового масиву}
      end;
   2: begin
        write('Workaround 2:');
        pr:=WORKAR1712; {Процедурному вказівнику присвоюється адреса алгоритму "вставка – обмін" з використанням елементів "уявного" вектора і переведення у відповідні індекси елементів заданого двовимірного масиву}
      end;

   3: begin
        write('Workaround 3:');
        pr:=WORKAR1713; {Процедурному вказівнику присвоюється адреса алгоритму "вставка – обмін" здійснюючи обхід безпосередньо по елементах заданого двовимірного масиву}
      end;
  end;{case}

  repeat
   case var_sort of {Вибір методу заповнення масиву}
    1:   begin
          SortArray(A);{Процедура впорядкованного заповнення масиву}
          B:=Time(pr);{Присвоєння комірці значення часу роботи алгоритма}
         end;
    2:   begin
          UnSortCopy(A); {Процедура копіюванння з додаткового рандомного масиву у необхідний}
          B:=Time(pr);{Присвоєння комірці значення часу роботи алгоритма}
         end;
    3:   begin
          BackSortArray(A); {Процедура заповнення обернено впорядкованного масиву}
          B:=Time(pr); {Присвоєння комірці вектора часу роботи алгоритма}
         end;
   end;{case}

   if var_sort<>3 then Write(B:10)
    else Writeln(B:10);
   inc(var_sort);
  until var_sort>3;
  inc(var_alg);
 until var_alg>3;
Writeln('Press Enter for continue');
readln;

vec:=SortVector; {Процедурному вказівнику присвоюється адреса алгоритму "вставка – обмін" сортування вектора}
  SortVect(C); {Процедура впорядкованного заповнення вектора}
  T:=TimeVector(vec);{Комірці запам'ятовування часу присвоюється значення часу роботи алгоритму}
  writeln('Sort Vector:',T*p); {Вивід на екран теоретичного значення роботи алгоритму з вектором}
  UnSortVect(C);{Процедура невпорядкованного заповнення вектора}
  T:=TimeVector(vec);{Комірці запам'ятовування часу присвоюється значення часу роботи алгоритму}
  writeln('UnSort Vector:',T*p);{Вивід на екран теоретичного значення роботи алгоритму з вектором}
  BackSortVect(C);{Процедура заповнення обернено впорядкованного вектора}
  T:=TimeVector(vec);{Комірці запам'ятовування часу присвоюється значення часу роботи алгоритму}
  writeln('BackSort Vector:',T*p); {Вивід на екран теоретичного значення роботи алгоритму з вектором}

  Writeln('Press Enter for continue');
ch:=readkey;
if ch=#32 then exit;  {Вихід з роботи процедури}  
end;

end.