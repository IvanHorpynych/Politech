unit WORKAR; {Процедура Workaround, у якій приведений алгоритм з необхідними методами обхода}

interface

uses GLOBAL; {Описання доступної інформації для їнших модулів}


procedure WORKAR1711(var A: arr); {Алгоритм "вставка – обмін" з використанням додаткового масиву}
procedure WORKAR1712(var A: arr); {Алгоритм "вставка – обмін" з використанням елементів "уявного" вектора і переведення у відповідні індекси елементів заданого двовимірного масиву}
procedure WORKAR1713(var A: arr); {Алгоритм "вставка – обмін", здійснюючи обхід безпосередньо по елементах заданого двовимірного масиву}
procedure SortVector(var C: vector); {Алгоритм "вставка – обмін" сортування вектора}

implementation


procedure WORKAR1711(var a: arr);{Алгоритм "вставка – обмін" з використанням додаткового масиву}

var ii, k, j, i, B:integer; {ii: координата одновимірного масиву; k,i,j: координати 3-вимірного масиву; B-додаткова комірка пам'яті}
    Z:vector; {Додатковий одновимірний масив}

begin
 for k:=1 to p do {Лічильники проходу по координатам 3-вимірного масиву}
  begin
   ii:=1;
   for i := 1 to m do
    for j := 1 to n do
    begin
      Z[ii] := a[k, i, j]; {Переписування елементів двовимірного масиву до одновимірного}
      inc(ii);{Після кожного проходу лічильника, кордината одновимірного масиву ii збільшується на 1}
    end;

    for i:=2 to (n*m) do {Прохід по одновимірному масиву}
      begin
        j:=i;
        while (j>1) and (Z[j]<Z[j-1]) do {Починається робота безпосередньо гібридного алгоритму "вставка – обмін"}
          begin
            B:=Z[j]; {Зміна елементів місцями}
            Z[j]:=Z[j-1];
            Z[j-1]:=B;
            j:=j-1;
          end;
      end;
   ii := 1;
    for i := 1 to m do {Лічильники проходу по координатам 2-вимірного масиву}
     for j := 1 to n do
      begin
       a[k, i, j]:= Z[ii]; {Переписування елементів одновимірного масиву  до двовимірного}
       inc(ii); {Після кожного проходу лічильника, кордината одновимірного масиву ii збільшується на 1}
      end;   
  end;
end;

procedure WORKAR1712(var a: arr);{Алгоритм "вставка – обмін" з використанням елементів "уявного" вектора і переведення у відповідні індекси елементів заданого двовимірного масиву}

var k,j, i, B:integer; {k,i,j: координати 3-вимірного масиву; B-додаткова комірка пам'яті}
begin
 for k:=1 to p do {Лічильники проходу по перерізам 3-вимірного масиву}
   for i:=2 to (n*m) do {Лічильники проходу по уявному вектору}
    begin
      j:=i;
      
      while (j>1) and (A[k,((j-1) div n)+1,((j-1) mod n)+1]<A[k,((j-2) div n)+1,((j-2) mod n)+1]) do {На місцях коодинат 3-вимірного масиву стоять формули переведення елементів "уявного" вектора у відповідні індекси двовимірного масиву}
        begin
          B:=A[k,((j-1) div n)+1,((j-1) mod n)+1]; {Зміна елементів місцями}
          A[k,((j-1) div n)+1,((j-1) mod n)+1]:=A[k,((j-2) div n)+1,((j-2) mod n)+1];
          A[k,((j-2) div n)+1,((j-2) mod n)+1]:=B;
          j:=j-1;
        end;
    end;      
end;

procedure WORKAR1713(var a: arr); {Алгоритм "вставка – обмін", здійснюючи обхід безпосередньо по елементах заданого двовимірного масиву}
var 
    i, j, k, Z, H, f,g, B: integer; {k,i,j: координати 3-вимірного масиву; B-додаткова комірка пам'яті; Z, H, f, g: додаткові змінні для проходу алгоритму по координатам перерізу}
begin
 for k:=1 to p do {Лічильник проходу по перерізам 3-вимірного масиву}
  for i:=1 to m do {Лічильники проходу по координатам перерізу}
    for j:=1 to n do 
    begin
        Z:=i; H:=j; {Копіювання координат елемента, для можливості їх зміни}
        if H<>1 then {перевірка на першість елемента у рядку}
          begin
            f:=Z; g:=H-1; {Якщо елемент не перший, то перехід додаткових координат g,f на попередій рядок не відбувається, відбувається перехід на сусідній елемент зліва}
          end
        else
          begin
            f:=Z-1; g:=n;{Якщо елемент перший, то відбувається перехід додаткових координат g,f на останній елемент попереднього рядка}
          end;
      
    while (H>=1) and (f>=1) and (A[k,Z,H]<A[k,f,g]) do {Перевірка за умовою алгоритму; H,f- перевірка для запобігання виходу за рамки двовимірного масиву}
      begin
        B:=A[k,Z,H]; {Зміна елементів місцями}
        A[k,Z,H]:=A[k,f,g];
        A[k,f,g]:=B;

        dec(H);   dec(g); {Зменьшення координат, відповідаючих за прохід по стовпцям елемента}
        
        if H=1 then {Перевірка на перщість координати елементу}
          begin
            g:=n; f:=Z-1; {Якщо елемент перший, то відбувається перехід додаткових координат g,f на останній елемент попереднього рядка}
          end
        else 
          if H=0 then {Перевірка на закіньчення рядка}
            begin
              H:=n; Z:=Z-1; {Якщо елементи у рядку закінчуються, то додаткові координати H,Z переходять на останній елемент попереднього рядка}
            end;
      end;
    end;
end;

procedure SortVector(var C:vector); {Алгоритм "вставка – обмін" сортування вектора}
var i,j,B: integer; {i,j: координати проходу  по вектору; B-додаткова комірка пам'яті;}
begin

  for i:=2 to (m*n) do {Лічильник проходу по вектору}
  begin
    j:=i;
    while (j>1) and (C[j]<C[j-1]) do {Починається робота безпосередньо гібридного алгоритму "вставка – обмін"}
    begin
      B:=C[j]; {Зміна елементів місцями}
      C[j]:=C[j-1];
      C[j-1]:=B;
      j:=j-1; {Зміщення координати вліво}
    end;
  end;
end;

end.