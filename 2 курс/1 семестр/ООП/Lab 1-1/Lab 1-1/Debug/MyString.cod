; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

	TITLE	D:\Documents\2 курс\1 семестр\ООП\LW1-1\MyString.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_substr
PUBLIC	_subseq
PUBLIC	_ispal
PUBLIC	_makepal
PUBLIC	_txt2double
PUBLIC	??_C@_07PACEEPLE@RUSSIAN?$AA@			; `string'
PUBLIC	__real@0000000000000000
EXTRN	__imp__strstr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp___msize:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__imp__atof:PROC
EXTRN	__imp__setlocale:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_07PACEEPLE@RUSSIAN?$AA@
CONST	SEGMENT
??_C@_07PACEEPLE@RUSSIAN?$AA@ DB 'RUSSIAN', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\documents\2 курс\1 семестр\ооп\lw1-1\mystring.c
;	COMDAT _txt2double
_TEXT	SEGMENT
_k$ = -68						; size = 4
_j$ = -56						; size = 4
_i$ = -44						; size = 4
_length$ = -32						; size = 4
_result_vect$ = -20					; size = 4
_current_numb$ = -8					; size = 4
_string$ = 8						; size = 4
_size$ = 12						; size = 4
_txt2double PROC					; COMDAT

; 68   : double* txt2double(const char *string, int *size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 69   : 	char *current_numb = (char*)calloc(strlen(string), sizeof(char));

  0001e	8b f4		 mov	 esi, esp
  00020	6a 01		 push	 1
  00022	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strlen
  0002b	83 c4 04	 add	 esp, 4
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00035	83 c4 08	 add	 esp, 8
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	89 45 f8	 mov	 DWORD PTR _current_numb$[ebp], eax

; 70   : 	double *result_vect = (double*)calloc(1, sizeof(double));

  00042	8b f4		 mov	 esi, esp
  00044	6a 08		 push	 8
  00046	6a 01		 push	 1
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0004e	83 c4 08	 add	 esp, 8
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	89 45 ec	 mov	 DWORD PTR _result_vect$[ebp], eax

; 71   : 	unsigned int length = strlen(string)-1;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _strlen
  00064	83 c4 04	 add	 esp, 4
  00067	83 e8 01	 sub	 eax, 1
  0006a	89 45 e0	 mov	 DWORD PTR _length$[ebp], eax

; 72   : 	unsigned int i = 0, j, k = 0;

  0006d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00074	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 73   : 	*size = 1;

  0007b	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0007e	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$LN2@txt2double:

; 74   : 	while (i <= length) {

  00084	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00087	3b 45 e0	 cmp	 eax, DWORD PTR _length$[ebp]
  0008a	0f 87 0b 01 00
	00		 ja	 $LN3@txt2double

; 75   : 		j = 0;

  00090	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN4@txt2double:

; 76   : 		while (i <= length && string[i] != ';') {

  00097	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	3b 45 e0	 cmp	 eax, DWORD PTR _length$[ebp]
  0009d	77 32		 ja	 SHORT $LN5@txt2double
  0009f	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000a2	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  000a5	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a8	83 f9 3b	 cmp	 ecx, 59			; 0000003bH
  000ab	74 24		 je	 SHORT $LN5@txt2double

; 77   : 			current_numb[j] = string[i];

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _current_numb$[ebp]
  000b0	03 45 c8	 add	 eax, DWORD PTR _j$[ebp]
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000b6	03 4d d4	 add	 ecx, DWORD PTR _i$[ebp]
  000b9	8a 11		 mov	 dl, BYTE PTR [ecx]
  000bb	88 10		 mov	 BYTE PTR [eax], dl

; 78   : 			j++; i++;

  000bd	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  000c0	83 c0 01	 add	 eax, 1
  000c3	89 45 c8	 mov	 DWORD PTR _j$[ebp], eax
  000c6	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000c9	83 c0 01	 add	 eax, 1
  000cc	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax

; 79   : 		}

  000cf	eb c6		 jmp	 SHORT $LN4@txt2double
$LN5@txt2double:

; 80   : 		while (j <= length) { current_numb[j] = '0'; j++; }

  000d1	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  000d4	3b 45 e0	 cmp	 eax, DWORD PTR _length$[ebp]
  000d7	77 14		 ja	 SHORT $LN7@txt2double
  000d9	8b 45 f8	 mov	 eax, DWORD PTR _current_numb$[ebp]
  000dc	03 45 c8	 add	 eax, DWORD PTR _j$[ebp]
  000df	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  000e2	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  000e5	83 c0 01	 add	 eax, 1
  000e8	89 45 c8	 mov	 DWORD PTR _j$[ebp], eax
  000eb	eb e4		 jmp	 SHORT $LN5@txt2double
$LN7@txt2double:

; 81   : 		i++; // Jumping over ';'

  000ed	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000f0	83 c0 01	 add	 eax, 1
  000f3	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax

; 82   : 		if (k > 0) result_vect = realloc(result_vect, _msize(result_vect)+sizeof(double));

  000f6	83 7d bc 00	 cmp	 DWORD PTR _k$[ebp], 0
  000fa	76 3c		 jbe	 SHORT $LN8@txt2double
  000fc	8b f4		 mov	 esi, esp
  000fe	8b 45 ec	 mov	 eax, DWORD PTR _result_vect$[ebp]
  00101	50		 push	 eax
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___msize
  00108	83 c4 04	 add	 esp, 4
  0010b	3b f4		 cmp	 esi, esp
  0010d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00112	33 c9		 xor	 ecx, ecx
  00114	83 c0 08	 add	 eax, 8
  00117	0f 92 c1	 setb	 cl
  0011a	f7 d9		 neg	 ecx
  0011c	0b c8		 or	 ecx, eax
  0011e	8b f4		 mov	 esi, esp
  00120	51		 push	 ecx
  00121	8b 55 ec	 mov	 edx, DWORD PTR _result_vect$[ebp]
  00124	52		 push	 edx
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  0012b	83 c4 08	 add	 esp, 8
  0012e	3b f4		 cmp	 esi, esp
  00130	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00135	89 45 ec	 mov	 DWORD PTR _result_vect$[ebp], eax
$LN8@txt2double:

; 83   : 		result_vect[k] = atof(current_numb);

  00138	8b f4		 mov	 esi, esp
  0013a	8b 45 f8	 mov	 eax, DWORD PTR _current_numb$[ebp]
  0013d	50		 push	 eax
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00144	83 c4 04	 add	 esp, 4
  00147	3b f4		 cmp	 esi, esp
  00149	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014e	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  00151	8b 55 ec	 mov	 edx, DWORD PTR _result_vect$[ebp]
  00154	dd 1c ca	 fstp	 QWORD PTR [edx+ecx*8]

; 84   : 		if (result_vect[k] == 0.0 && current_numb[0] != '0') *size = 0;

  00157	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  0015a	8b 4d ec	 mov	 ecx, DWORD PTR _result_vect$[ebp]
  0015d	f2 0f 10 04 c1	 movsd	 xmm0, QWORD PTR [ecx+eax*8]
  00162	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0016a	9f		 lahf
  0016b	f6 c4 44	 test	 ah, 68			; 00000044H
  0016e	7a 1d		 jp	 SHORT $LN9@txt2double
  00170	b8 01 00 00 00	 mov	 eax, 1
  00175	6b c8 00	 imul	 ecx, eax, 0
  00178	8b 55 f8	 mov	 edx, DWORD PTR _current_numb$[ebp]
  0017b	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0017f	83 f8 30	 cmp	 eax, 48			; 00000030H
  00182	74 09		 je	 SHORT $LN9@txt2double
  00184	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00187	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN9@txt2double:

; 85   : 		k++;

  0018d	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  00190	83 c0 01	 add	 eax, 1
  00193	89 45 bc	 mov	 DWORD PTR _k$[ebp], eax

; 86   : 	}

  00196	e9 e9 fe ff ff	 jmp	 $LN2@txt2double
$LN3@txt2double:

; 87   : 	if (*size != 0) *size = k;

  0019b	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0019e	83 38 00	 cmp	 DWORD PTR [eax], 0
  001a1	74 08		 je	 SHORT $LN10@txt2double
  001a3	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  001a6	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  001a9	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@txt2double:

; 88   : 	return (result_vect);

  001ab	8b 45 ec	 mov	 eax, DWORD PTR _result_vect$[ebp]
  001ae	eb 2c		 jmp	 SHORT $LN1@txt2double

; 89   : 	free(result_vect); free(current_numb);

  001b0	8b f4		 mov	 esi, esp
  001b2	8b 45 ec	 mov	 eax, DWORD PTR _result_vect$[ebp]
  001b5	50		 push	 eax
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  001bc	83 c4 04	 add	 esp, 4
  001bf	3b f4		 cmp	 esi, esp
  001c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c6	8b f4		 mov	 esi, esp
  001c8	8b 45 f8	 mov	 eax, DWORD PTR _current_numb$[ebp]
  001cb	50		 push	 eax
  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  001d2	83 c4 04	 add	 esp, 4
  001d5	3b f4		 cmp	 esi, esp
  001d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@txt2double:

; 90   : }

  001dc	5f		 pop	 edi
  001dd	5e		 pop	 esi
  001de	5b		 pop	 ebx
  001df	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  001e5	3b ec		 cmp	 ebp, esp
  001e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c3		 ret	 0
_txt2double ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\documents\2 курс\1 семестр\ооп\lw1-1\mystring.c
;	COMDAT _makepal
_TEXT	SEGMENT
_buf$ = -65						; size = 1
_i$ = -56						; size = 4
_index$ = -44						; size = 4
_tail$ = -32						; size = 4
_palynd_part$ = -20					; size = 4
_reс_string$ = -8					; size = 4
_string$ = 8						; size = 4
_makepal PROC						; COMDAT

; 43   : char* makepal(const char *string) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 44   : 	setlocale(LC_ALL, "RUSSIAN");

  0001e	8b f4		 mov	 esi, esp
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_07PACEEPLE@RUSSIAN?$AA@
  00025	6a 00		 push	 0
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
  0002d	83 c4 08	 add	 esp, 8
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 45   : 	char *reс_string = (char*)calloc(strlen(string), sizeof(char));

  00037	8b f4		 mov	 esi, esp
  00039	6a 01		 push	 1
  0003b	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _strlen
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0004e	83 c4 08	 add	 esp, 8
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	89 45 f8	 mov	 DWORD PTR _reс_string$[ebp], eax

; 46   : 	char *palynd_part = (char*)calloc(strlen(string), sizeof(char));

  0005b	8b f4		 mov	 esi, esp
  0005d	6a 01		 push	 1
  0005f	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _strlen
  00068	83 c4 04	 add	 esp, 4
  0006b	50		 push	 eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00072	83 c4 08	 add	 esp, 8
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	89 45 ec	 mov	 DWORD PTR _palynd_part$[ebp], eax

; 47   : 	char *tail = (char*)calloc(strlen(string), sizeof(char));

  0007f	8b f4		 mov	 esi, esp
  00081	6a 01		 push	 1
  00083	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _strlen
  0008c	83 c4 04	 add	 esp, 4
  0008f	50		 push	 eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00096	83 c4 08	 add	 esp, 8
  00099	3b f4		 cmp	 esi, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	89 45 e0	 mov	 DWORD PTR _tail$[ebp], eax

; 48   : 	unsigned int index = 0, i;

  000a3	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _index$[ebp], 0

; 49   : 	char buf;
; 50   : 	if (ispal(string) == 1) return (string);

  000aa	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 _ispal
  000b3	83 c4 04	 add	 esp, 4
  000b6	0f be c8	 movsx	 ecx, al
  000b9	83 f9 01	 cmp	 ecx, 1
  000bc	75 08		 jne	 SHORT $LN13@makepal
  000be	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000c1	e9 79 01 00 00	 jmp	 $LN1@makepal
$LN13@makepal:

; 51   : 	reс_string = strcpy(reс_string, string);

  000c6	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d f8	 mov	 ecx, DWORD PTR _reс_string$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 _strcpy
  000d3	83 c4 08	 add	 esp, 8
  000d6	89 45 f8	 mov	 DWORD PTR _reс_string$[ebp], eax

; 52   : 	palynd_part = strcpy(palynd_part, string);

  000d9	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR _palynd_part$[ebp]
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 _strcpy
  000e6	83 c4 08	 add	 esp, 8
  000e9	89 45 ec	 mov	 DWORD PTR _palynd_part$[ebp], eax
$LN2@makepal:

; 53   : 	while (ispal(palynd_part) != 1) {

  000ec	8b 45 ec	 mov	 eax, DWORD PTR _palynd_part$[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 _ispal
  000f5	83 c4 04	 add	 esp, 4
  000f8	0f be c8	 movsx	 ecx, al
  000fb	83 f9 01	 cmp	 ecx, 1
  000fe	74 75		 je	 SHORT $LN3@makepal

; 54   : 		index++;

  00100	8b 45 d4	 mov	 eax, DWORD PTR _index$[ebp]
  00103	83 c0 01	 add	 eax, 1
  00106	89 45 d4	 mov	 DWORD PTR _index$[ebp], eax

; 55   : 		for (i = 0; i <= index - 1; i++) tail[i] = string[i];

  00109	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00110	eb 09		 jmp	 SHORT $LN6@makepal
$LN4@makepal:
  00112	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  00115	83 c0 01	 add	 eax, 1
  00118	89 45 c8	 mov	 DWORD PTR _i$[ebp], eax
$LN6@makepal:
  0011b	8b 45 d4	 mov	 eax, DWORD PTR _index$[ebp]
  0011e	83 e8 01	 sub	 eax, 1
  00121	39 45 c8	 cmp	 DWORD PTR _i$[ebp], eax
  00124	77 12		 ja	 SHORT $LN5@makepal
  00126	8b 45 e0	 mov	 eax, DWORD PTR _tail$[ebp]
  00129	03 45 c8	 add	 eax, DWORD PTR _i$[ebp]
  0012c	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0012f	03 4d c8	 add	 ecx, DWORD PTR _i$[ebp]
  00132	8a 11		 mov	 dl, BYTE PTR [ecx]
  00134	88 10		 mov	 BYTE PTR [eax], dl
  00136	eb da		 jmp	 SHORT $LN4@makepal
$LN5@makepal:

; 56   : 		for (i = index; i <= strlen(string); i++) palynd_part[i - index] = string[i];

  00138	8b 45 d4	 mov	 eax, DWORD PTR _index$[ebp]
  0013b	89 45 c8	 mov	 DWORD PTR _i$[ebp], eax
  0013e	eb 09		 jmp	 SHORT $LN9@makepal
$LN7@makepal:
  00140	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  00143	83 c0 01	 add	 eax, 1
  00146	89 45 c8	 mov	 DWORD PTR _i$[ebp], eax
$LN9@makepal:
  00149	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _strlen
  00152	83 c4 04	 add	 esp, 4
  00155	39 45 c8	 cmp	 DWORD PTR _i$[ebp], eax
  00158	77 16		 ja	 SHORT $LN8@makepal
  0015a	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  0015d	2b 45 d4	 sub	 eax, DWORD PTR _index$[ebp]
  00160	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00163	03 4d c8	 add	 ecx, DWORD PTR _i$[ebp]
  00166	8b 55 ec	 mov	 edx, DWORD PTR _palynd_part$[ebp]
  00169	8a 09		 mov	 cl, BYTE PTR [ecx]
  0016b	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0016e	eb d0		 jmp	 SHORT $LN7@makepal
$LN8@makepal:

; 57   : 	}

  00170	e9 77 ff ff ff	 jmp	 $LN2@makepal
$LN3@makepal:

; 58   : 	for (i = 0; i <= (strlen(tail) - 1) / 2; i++) {

  00175	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0017c	eb 09		 jmp	 SHORT $LN12@makepal
$LN10@makepal:
  0017e	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  00181	83 c0 01	 add	 eax, 1
  00184	89 45 c8	 mov	 DWORD PTR _i$[ebp], eax
$LN12@makepal:
  00187	8b 45 e0	 mov	 eax, DWORD PTR _tail$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _strlen
  00190	83 c4 04	 add	 esp, 4
  00193	83 e8 01	 sub	 eax, 1
  00196	d1 e8		 shr	 eax, 1
  00198	39 45 c8	 cmp	 DWORD PTR _i$[ebp], eax
  0019b	77 48		 ja	 SHORT $LN11@makepal

; 59   : 		buf = tail[i];

  0019d	8b 45 e0	 mov	 eax, DWORD PTR _tail$[ebp]
  001a0	03 45 c8	 add	 eax, DWORD PTR _i$[ebp]
  001a3	8a 08		 mov	 cl, BYTE PTR [eax]
  001a5	88 4d bf	 mov	 BYTE PTR _buf$[ebp], cl

; 60   : 		tail[i] = tail[strlen(tail) - 1 - i];

  001a8	8b 45 e0	 mov	 eax, DWORD PTR _tail$[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _strlen
  001b1	83 c4 04	 add	 esp, 4
  001b4	83 e8 01	 sub	 eax, 1
  001b7	2b 45 c8	 sub	 eax, DWORD PTR _i$[ebp]
  001ba	8b 4d e0	 mov	 ecx, DWORD PTR _tail$[ebp]
  001bd	03 4d c8	 add	 ecx, DWORD PTR _i$[ebp]
  001c0	8b 55 e0	 mov	 edx, DWORD PTR _tail$[ebp]
  001c3	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  001c6	88 01		 mov	 BYTE PTR [ecx], al

; 61   : 		tail[strlen(tail) - 1 - i] = buf;

  001c8	8b 45 e0	 mov	 eax, DWORD PTR _tail$[ebp]
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 _strlen
  001d1	83 c4 04	 add	 esp, 4
  001d4	83 e8 01	 sub	 eax, 1
  001d7	2b 45 c8	 sub	 eax, DWORD PTR _i$[ebp]
  001da	8b 4d e0	 mov	 ecx, DWORD PTR _tail$[ebp]
  001dd	8a 55 bf	 mov	 dl, BYTE PTR _buf$[ebp]
  001e0	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 62   : 	}

  001e3	eb 99		 jmp	 SHORT $LN10@makepal
$LN11@makepal:

; 63   : 	reс_string = strcat(reс_string, tail);

  001e5	8b 45 e0	 mov	 eax, DWORD PTR _tail$[ebp]
  001e8	50		 push	 eax
  001e9	8b 4d f8	 mov	 ecx, DWORD PTR _reс_string$[ebp]
  001ec	51		 push	 ecx
  001ed	e8 00 00 00 00	 call	 _strcat
  001f2	83 c4 08	 add	 esp, 8
  001f5	89 45 f8	 mov	 DWORD PTR _reс_string$[ebp], eax

; 64   : 	return reс_string;

  001f8	8b 45 f8	 mov	 eax, DWORD PTR _reс_string$[ebp]
  001fb	eb 42		 jmp	 SHORT $LN1@makepal

; 65   : 	free(reс_string); free(palynd_part); free(tail);

  001fd	8b f4		 mov	 esi, esp
  001ff	8b 45 f8	 mov	 eax, DWORD PTR _reс_string$[ebp]
  00202	50		 push	 eax
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00209	83 c4 04	 add	 esp, 4
  0020c	3b f4		 cmp	 esi, esp
  0020e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00213	8b f4		 mov	 esi, esp
  00215	8b 45 ec	 mov	 eax, DWORD PTR _palynd_part$[ebp]
  00218	50		 push	 eax
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0021f	83 c4 04	 add	 esp, 4
  00222	3b f4		 cmp	 esi, esp
  00224	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00229	8b f4		 mov	 esi, esp
  0022b	8b 45 e0	 mov	 eax, DWORD PTR _tail$[ebp]
  0022e	50		 push	 eax
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00235	83 c4 04	 add	 esp, 4
  00238	3b f4		 cmp	 esi, esp
  0023a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@makepal:

; 66   : }

  0023f	5f		 pop	 edi
  00240	5e		 pop	 esi
  00241	5b		 pop	 ebx
  00242	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00248	3b ec		 cmp	 ebp, esp
  0024a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0024f	8b e5		 mov	 esp, ebp
  00251	5d		 pop	 ebp
  00252	c3		 ret	 0
_makepal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\documents\2 курс\1 семестр\ооп\lw1-1\mystring.c
;	COMDAT _ispal
_TEXT	SEGMENT
_i$ = -32						; size = 4
_length$ = -20						; size = 4
_res$ = -8						; size = 4
_string$ = 8						; size = 4
_ispal	PROC						; COMDAT

; 32   : char ispal (const char *string) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 33   : 	int res = 1;

  0001e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _res$[ebp], 1

; 34   : 	unsigned int length = strlen(string)-1;

  00025	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _strlen
  0002e	83 c4 04	 add	 esp, 4
  00031	83 e8 01	 sub	 eax, 1
  00034	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 35   : 	unsigned int i = 0;

  00037	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@ispal:

; 36   : 	while (i <= length/2 && res == 1) {

  0003e	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00041	d1 e8		 shr	 eax, 1
  00043	39 45 e0	 cmp	 DWORD PTR _i$[ebp], eax
  00046	77 32		 ja	 SHORT $LN3@ispal
  00048	83 7d f8 01	 cmp	 DWORD PTR _res$[ebp], 1
  0004c	75 2c		 jne	 SHORT $LN3@ispal

; 37   : 		if (string[i] != string[length-i]) res = 0;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00051	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  00054	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00057	8b 55 ec	 mov	 edx, DWORD PTR _length$[ebp]
  0005a	2b 55 e0	 sub	 edx, DWORD PTR _i$[ebp]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00060	0f be 14 10	 movsx	 edx, BYTE PTR [eax+edx]
  00064	3b ca		 cmp	 ecx, edx
  00066	74 07		 je	 SHORT $LN4@ispal
  00068	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _res$[ebp], 0
$LN4@ispal:

; 38   : 		i++;

  0006f	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax

; 39   : 	}

  00078	eb c4		 jmp	 SHORT $LN2@ispal
$LN3@ispal:

; 40   : 	return res;

  0007a	8a 45 f8	 mov	 al, BYTE PTR _res$[ebp]

; 41   : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_ispal	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\documents\2 курс\1 семестр\ооп\lw1-1\mystring.c
;	COMDAT _subseq
_TEXT	SEGMENT
_j0$ = -92						; size = 4
_i0$ = -80						; size = 4
_j$ = -68						; size = 4
_i$ = -56						; size = 4
_length2$ = -44						; size = 4
_length1$ = -32						; size = 4
_max_length$ = -20					; size = 4
_current_length$ = -8					; size = 4
_string1$ = 8						; size = 4
_string2$ = 12						; size = 4
_subseq	PROC						; COMDAT

; 12   : int subseq (const char *string1, const char *string2) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 13   : 	int current_length = 0, max_length = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _current_length$[ebp], 0
  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _max_length$[ebp], 0

; 14   : 	unsigned int length1 = strlen(string1), length2 = strlen(string2);

  0002c	8b 45 08	 mov	 eax, DWORD PTR _string1$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _strlen
  00035	83 c4 04	 add	 esp, 4
  00038	89 45 e0	 mov	 DWORD PTR _length1$[ebp], eax
  0003b	8b 45 0c	 mov	 eax, DWORD PTR _string2$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _strlen
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 d4	 mov	 DWORD PTR _length2$[ebp], eax

; 15   : 	unsigned int i, j, i0, j0;
; 16   : 	for (i = 0; i < length1; i++) {

  0004a	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00051	eb 09		 jmp	 SHORT $LN4@subseq
$LN2@subseq:
  00053	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 c8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@subseq:
  0005c	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  0005f	3b 45 e0	 cmp	 eax, DWORD PTR _length1$[ebp]
  00062	0f 83 9e 00 00
	00		 jae	 $LN3@subseq

; 17   : 		for (j = 0; j < length2; j++) {

  00068	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0006f	eb 09		 jmp	 SHORT $LN7@subseq
$LN5@subseq:
  00071	8b 45 bc	 mov	 eax, DWORD PTR _j$[ebp]
  00074	83 c0 01	 add	 eax, 1
  00077	89 45 bc	 mov	 DWORD PTR _j$[ebp], eax
$LN7@subseq:
  0007a	8b 45 bc	 mov	 eax, DWORD PTR _j$[ebp]
  0007d	3b 45 d4	 cmp	 eax, DWORD PTR _length2$[ebp]
  00080	73 7f		 jae	 SHORT $LN6@subseq

; 18   : 			if (string2[j] == string1[i]) {

  00082	8b 45 0c	 mov	 eax, DWORD PTR _string2$[ebp]
  00085	03 45 bc	 add	 eax, DWORD PTR _j$[ebp]
  00088	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008b	8b 55 08	 mov	 edx, DWORD PTR _string1$[ebp]
  0008e	03 55 c8	 add	 edx, DWORD PTR _i$[ebp]
  00091	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00094	3b c8		 cmp	 ecx, eax
  00096	75 64		 jne	 SHORT $LN10@subseq

; 19   : 				j0 = j; i0 = i;

  00098	8b 45 bc	 mov	 eax, DWORD PTR _j$[ebp]
  0009b	89 45 a4	 mov	 DWORD PTR _j0$[ebp], eax
  0009e	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  000a1	89 45 b0	 mov	 DWORD PTR _i0$[ebp], eax
$LN8@subseq:

; 20   : 				while (i0 <= length1 && j0 <= length2 && string1[i0] == string2[j0]) {

  000a4	8b 45 b0	 mov	 eax, DWORD PTR _i0$[ebp]
  000a7	3b 45 e0	 cmp	 eax, DWORD PTR _length1$[ebp]
  000aa	77 3b		 ja	 SHORT $LN9@subseq
  000ac	8b 45 a4	 mov	 eax, DWORD PTR _j0$[ebp]
  000af	3b 45 d4	 cmp	 eax, DWORD PTR _length2$[ebp]
  000b2	77 33		 ja	 SHORT $LN9@subseq
  000b4	8b 45 08	 mov	 eax, DWORD PTR _string1$[ebp]
  000b7	03 45 b0	 add	 eax, DWORD PTR _i0$[ebp]
  000ba	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000bd	8b 55 0c	 mov	 edx, DWORD PTR _string2$[ebp]
  000c0	03 55 a4	 add	 edx, DWORD PTR _j0$[ebp]
  000c3	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000c6	3b c8		 cmp	 ecx, eax
  000c8	75 1d		 jne	 SHORT $LN9@subseq

; 21   : 					current_length++;

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _current_length$[ebp]
  000cd	83 c0 01	 add	 eax, 1
  000d0	89 45 f8	 mov	 DWORD PTR _current_length$[ebp], eax

; 22   : 					i0++; j0++;

  000d3	8b 45 b0	 mov	 eax, DWORD PTR _i0$[ebp]
  000d6	83 c0 01	 add	 eax, 1
  000d9	89 45 b0	 mov	 DWORD PTR _i0$[ebp], eax
  000dc	8b 45 a4	 mov	 eax, DWORD PTR _j0$[ebp]
  000df	83 c0 01	 add	 eax, 1
  000e2	89 45 a4	 mov	 DWORD PTR _j0$[ebp], eax

; 23   : 				}

  000e5	eb bd		 jmp	 SHORT $LN8@subseq
$LN9@subseq:

; 24   : 				if (current_length > max_length) max_length = current_length;

  000e7	8b 45 f8	 mov	 eax, DWORD PTR _current_length$[ebp]
  000ea	3b 45 ec	 cmp	 eax, DWORD PTR _max_length$[ebp]
  000ed	7e 06		 jle	 SHORT $LN11@subseq
  000ef	8b 45 f8	 mov	 eax, DWORD PTR _current_length$[ebp]
  000f2	89 45 ec	 mov	 DWORD PTR _max_length$[ebp], eax
$LN11@subseq:

; 25   : 				current_length = 0;

  000f5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _current_length$[ebp], 0
$LN10@subseq:

; 26   : 			}
; 27   : 		}

  000fc	e9 70 ff ff ff	 jmp	 $LN5@subseq
$LN6@subseq:

; 28   : 	}

  00101	e9 4d ff ff ff	 jmp	 $LN2@subseq
$LN3@subseq:

; 29   : 	return max_length; 

  00106	8b 45 ec	 mov	 eax, DWORD PTR _max_length$[ebp]

; 30   : }

  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx
  0010c	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  00112	3b ec		 cmp	 ebp, esp
  00114	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
_subseq	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\documents\2 курс\1 семестр\ооп\lw1-1\mystring.c
;	COMDAT _substr
_TEXT	SEGMENT
_sub_index$ = -20					; size = 4
_sub_prt$ = -8						; size = 4
_string1$ = 8						; size = 4
_string2$ = 12						; size = 4
_substr	PROC						; COMDAT

; 5    : int substr (const char *string1, const char *string2) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 6    : 	char *sub_prt = strstr(string1, string2);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 0c	 mov	 eax, DWORD PTR _string2$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _string1$[ebp]
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  0002e	83 c4 08	 add	 esp, 8
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	89 45 f8	 mov	 DWORD PTR _sub_prt$[ebp], eax

; 7    : 	int sub_index = -1;

  0003b	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _sub_index$[ebp], -1

; 8    : 	if (sub_prt != NULL) sub_index = sub_prt-string1;

  00042	83 7d f8 00	 cmp	 DWORD PTR _sub_prt$[ebp], 0
  00046	74 09		 je	 SHORT $LN2@substr
  00048	8b 45 f8	 mov	 eax, DWORD PTR _sub_prt$[ebp]
  0004b	2b 45 08	 sub	 eax, DWORD PTR _string1$[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR _sub_index$[ebp], eax
$LN2@substr:

; 9    : 	return sub_index + 1;

  00051	8b 45 ec	 mov	 eax, DWORD PTR _sub_index$[ebp]
  00054	83 c0 01	 add	 eax, 1

; 10   : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_substr	ENDP
_TEXT	ENDS
END
